# Overview
Total Infection is a simple graph connected component problem; Limited Infection is the same except we're aiming to end up with close to a given number of infected users.

# Total Infection
I find graph problems to be comfortable in C++, because explicit/static typing will make the node/edge models unambiguous. I'll need to write a node class, and because the edges are relatively simple I think each node will just contain a vector of node pointers (no need for a seperat edge class). If I get to the point where I want to do a visualization (optional) I would hate to do that in C++, so I'll probably favor figuring out some way to do that in Python. Starting out I'll probably just pull input from a text file (or multiply text files) but if I have time I'll set it up to pull data from a SQLite database (because 1. relational databases seem good for graph problems, and 2. it'll be easy to send test SQLite databases over to to Jules).

# Limited Infection
The dumb way of doing this is to just count up to the number of people we want to infect (each new infection increments the counter) then we bail when we hit the limit, but that will lead to a lot of split components (teachers and students being on different versions). Assuming we have several relatively small components (which seems like a valid assumption given what I know about Kahn Academy) we could implement a similar process, except we only check for a bail condition after we've completely infected a component. This will get us close (depending on average component size) and will usually over shoot. This gets us close to what we want, and will be pretty efficient, so this is what i'll go for first.

# Update 1
Total infection is now working for 4 test cases and Limited Infection is also working for 4 test cases. If I choose to do visualization I think it'd be better to just go for a c++ library instead of switching languages mid-process. OGDF (Open Graph Drawing Framework) looks like a good place to start if I decide to do visualization. Both are currently just pulling input from text files (text files that are addmitedly not readable) and I think if I do anything more it ought to be porting that to a sqlite db. All in all it shouldn't be much of a problem; I just have to rewrite the readInput function which is actually identical in both programs (maybe I pull it out into a seperate file to make it more modular?) and implement a writeOutput. The question is if I can do that in a smarter way than just pulling everything from the database and then deleting everything from the database and then writing everything to the database.

# Update 2
So I wrote exactInfection.cpp; the big decision there was about whether to use a power set enumeration via bit arithmetic, or via recursion; the bit arithmetic power set enumeration is clean, the only problem is it basically maxes out at the size of a long long int, which on most machines will be 64 or less. I want this to be scalable so I opted for recursion. We could pass everything in as an argument (and keep passing it on every time we make a new call), but it'll be much cleaner and more efficient to make a recusive solver class to store all the data we'll want to read and mutate while in our recusive stack.
Modularity--the readInput function is a fairly large piece of code, and if I change some wording it can be generalized to all three programs. So I'll make the changes and make it its own file. Same goes with userNode.cpp; the exactInfection is a superset of the previous userNodes, so I can put that in the home directory and have all of them link to it. #KeepingItDRY
